<class><keyword> Class </keyword><identifier> Ball </identifier><symbol> { </symbol><keyword> Int </keyword><identifier> x </identifier><symbol> , </symbol><identifier> y </identifier><symbol> ; </symbol><keyword> Int </keyword><identifier> lengthx </identifier><symbol> , </symbol><identifier> lengthy </identifier><symbol> ; </symbol><keyword> Int </keyword><identifier> d </identifier><symbol> , </symbol><identifier> straightD </identifier><symbol> , </symbol><identifier> diagonalD </identifier><symbol> ; </symbol><keyword> Boolean </keyword><identifier> invert </identifier><symbol> , </symbol><identifier> positivex </identifier><symbol> , </symbol><identifier> positivey </identifier><symbol> ; </symbol><keyword> Int </keyword><identifier> leftWall </identifier><symbol> , </symbol><identifier> rightWall </identifier><symbol> , </symbol><identifier> topWall </identifier><symbol> , </symbol><identifier> bottomWall </identifier><symbol> ; </symbol><keyword> Int </keyword><identifier> wall </identifier><symbol> ; </symbol><subroutineDec><keyword> Constructor </keyword><identifier> Ball </identifier><identifier> new </identifier><symbol> ( </symbol><parameterList><keyword> Int </keyword><identifier> Ax </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> Ay </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> AleftWall </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> ArightWall </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> AtopWall </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> AbottomWall </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> Ax </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> Ay </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> leftWall </identifier><symbol> = </symbol><expression><term><identifier> AleftWall </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> rightWall </identifier><symbol> = </symbol><expression><term><identifier> ArightWall </identifier></term><symbol> - </symbol><term><integerConstant> 6 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> topWall </identifier><symbol> = </symbol><expression><term><identifier> AtopWall </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> bottomWall </identifier><symbol> = </symbol><expression><term><identifier> AbottomWall </identifier></term><symbol> - </symbol><term><integerConstant> 6 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><doStatement><keyword> Do </keyword><identifier> show </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><expression><term><keyword> This </keyword></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> dispose </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> Do </keyword><identifier> Memory </identifier><symbol> . </symbol><identifier> deAlloc </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> This </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> show </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> Do </keyword><identifier> Screen </identifier><symbol> . </symbol><identifier> setColor </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> True </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><doStatement><keyword> Do </keyword><identifier> draw </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> hide </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> Do </keyword><identifier> Screen </identifier><symbol> . </symbol><identifier> setColor </identifier><symbol> ( </symbol><expressionList><expression><term><keyword> False </keyword></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><doStatement><keyword> Do </keyword><identifier> draw </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> draw </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> Do </keyword><identifier> Screen </identifier><symbol> . </symbol><identifier> drawRectangle </identifier><symbol> ( </symbol><expressionList><expression><term><identifier> x </identifier></term></expression><symbol> , </symbol><expression><term><identifier> y </identifier></term></expression><symbol> , </symbol><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression><symbol> , </symbol><expression><term><identifier> y </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Int </keyword><identifier> getLeft </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><returnStatement><keyword> Return </keyword><expression><term><identifier> x </identifier></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Int </keyword><identifier> getRight </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><returnStatement><keyword> Return </keyword><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><integerConstant> 5 </integerConstant></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> setDestination </identifier><symbol> ( </symbol><parameterList><keyword> Int </keyword><identifier> destx </identifier><symbol> , </symbol><keyword> Int </keyword><identifier> desty </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><varDec><keyword> Var </keyword><keyword> Int </keyword><identifier> dx </identifier><symbol> , </symbol><identifier> dy </identifier><symbol> , </symbol><identifier> temp </identifier><symbol> ; </symbol></varDec><statements><letStatement><keyword> Let </keyword><identifier> lengthx </identifier><symbol> = </symbol><expression><term><identifier> destx </identifier></term><symbol> - </symbol><term><identifier> x </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> lengthy </identifier><symbol> = </symbol><expression><term><identifier> desty </identifier></term><symbol> - </symbol><term><identifier> y </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> dx </identifier><symbol> = </symbol><expression><term><identifier> Math </identifier><symbol> . </symbol><identifier> abs </identifier><symbol> ( </symbol><expressionList><expression><term><identifier> lengthx </identifier></term></expression></expressionList><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> dy </identifier><symbol> = </symbol><expression><term><identifier> Math </identifier><symbol> . </symbol><identifier> abs </identifier><symbol> ( </symbol><expressionList><expression><term><identifier> lengthy </identifier></term></expression></expressionList><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> invert </identifier><symbol> = </symbol><expression><term><expression><term><identifier> dx </identifier></term><symbol> &lt; </symbol><term><identifier> dy </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> temp </identifier><symbol> = </symbol><expression><term><identifier> dx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> dx </identifier><symbol> = </symbol><expression><term><identifier> dy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> dy </identifier><symbol> = </symbol><expression><term><identifier> temp </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> positivex </identifier><symbol> = </symbol><expression><term><expression><term><identifier> y </identifier></term><symbol> &lt; </symbol><term><identifier> desty </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> positivey </identifier><symbol> = </symbol><expression><term><expression><term><identifier> x </identifier></term><symbol> &lt; </symbol><term><identifier> destx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> positivex </identifier><symbol> = </symbol><expression><term><expression><term><identifier> x </identifier></term><symbol> &lt; </symbol><term><identifier> destx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> positivey </identifier><symbol> = </symbol><expression><term><expression><term><identifier> y </identifier></term><symbol> &lt; </symbol><term><identifier> desty </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><letStatement><keyword> Let </keyword><identifier> d </identifier><symbol> = </symbol><expression><term><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><identifier> dy </identifier></term></expression><symbol> ) </symbol></term><symbol> - </symbol><term><identifier> dx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> straightD </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><identifier> dy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> diagonalD </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term><symbol> * </symbol><term><expression><term><identifier> dy </identifier></term><symbol> - </symbol><term><identifier> dx </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Int </keyword><identifier> move </identifier><symbol> ( </symbol><parameterList></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><statements><doStatement><keyword> Do </keyword><identifier> hide </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> d </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> d </identifier><symbol> = </symbol><expression><term><identifier> d </identifier></term><symbol> + </symbol><term><identifier> straightD </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> d </identifier><symbol> = </symbol><expression><term><identifier> d </identifier></term><symbol> + </symbol><term><identifier> diagonalD </identifier></term></expression><symbol> ; </symbol></letStatement><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> positivey </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> positivex </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> invert </identifier></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> - </symbol><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><expression><term><identifier> x </identifier></term><symbol> &gt; </symbol><term><identifier> leftWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 1 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> leftWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><expression><term><identifier> x </identifier></term><symbol> &lt; </symbol><term><identifier> rightWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 2 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> x </identifier><symbol> = </symbol><expression><term><identifier> rightWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><expression><term><identifier> y </identifier></term><symbol> &gt; </symbol><term><identifier> topWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 3 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> topWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><symbol> ~ </symbol><term><expression><term><identifier> y </identifier></term><symbol> &lt; </symbol><term><identifier> bottomWall </identifier></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> wall </identifier><symbol> = </symbol><expression><term><integerConstant> 4 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> y </identifier><symbol> = </symbol><expression><term><identifier> bottomWall </identifier></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><doStatement><keyword> Do </keyword><identifier> show </identifier><symbol> ( </symbol><expressionList></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><expression><term><identifier> wall </identifier></term></expression><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><subroutineDec><keyword> Method </keyword><keyword> Void </keyword><identifier> bounce </identifier><symbol> ( </symbol><parameterList><keyword> Int </keyword><identifier> bouncingDirection </identifier></parameterList><symbol> ) </symbol><subroutineBody><symbol> { </symbol><varDec><keyword> Var </keyword><keyword> Int </keyword><identifier> newx </identifier><symbol> , </symbol><identifier> newy </identifier><symbol> , </symbol><identifier> divLengthx </identifier><symbol> , </symbol><identifier> divLengthy </identifier><symbol> , </symbol><identifier> factor </identifier><symbol> ; </symbol></varDec><statements><letStatement><keyword> Let </keyword><identifier> divLengthx </identifier><symbol> = </symbol><expression><term><identifier> lengthx </identifier></term><symbol> / </symbol><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> divLengthy </identifier><symbol> = </symbol><expression><term><identifier> lengthy </identifier></term><symbol> / </symbol><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> bouncingDirection </identifier></term><symbol> = </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 10 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><expression><term><expression><term><symbol> ~ </symbol><term><expression><term><identifier> lengthx </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol></term></term></expression><symbol> ) </symbol></term><symbol> & </symbol><term><expression><term><identifier> bouncingDirection </identifier></term><symbol> = </symbol><term><integerConstant> 1 </integerConstant></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> | </symbol><term><expression><term><expression><term><identifier> lengthx </identifier></term><symbol> &lt; </symbol><term><integerConstant> 0 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> & </symbol><term><expression><term><identifier> bouncingDirection </identifier></term><symbol> = </symbol><term><expression><term><symbol> - </symbol><term><integerConstant> 1 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 20 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> factor </identifier><symbol> = </symbol><expression><term><integerConstant> 5 </integerConstant></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> wall </identifier></term><symbol> = </symbol><term><integerConstant> 1 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><integerConstant> 506 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><expression><term><identifier> divLengthy </identifier></term><symbol> * </symbol><term><expression><term><symbol> - </symbol><term><integerConstant> 50 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier> divLengthx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> + </symbol><term><expression><term><identifier> newy </identifier></term><symbol> * </symbol><term><identifier> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> wall </identifier></term><symbol> = </symbol><term><integerConstant> 2 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><expression><term><identifier> divLengthy </identifier></term><symbol> * </symbol><term><integerConstant> 50 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier> divLengthx </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><identifier> y </identifier></term><symbol> + </symbol><term><expression><term><identifier> newy </identifier></term><symbol> * </symbol><term><identifier> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><keyword> If </keyword><symbol> ( </symbol><expression><term><identifier> wall </identifier></term><symbol> = </symbol><term><integerConstant> 3 </integerConstant></term></expression><symbol> ) </symbol><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><integerConstant> 250 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><expression><term><identifier> divLengthx </identifier></term><symbol> * </symbol><term><expression><term><symbol> - </symbol><term><integerConstant> 25 </integerConstant></term></term></expression><symbol> ) </symbol></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier> divLengthy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><expression><term><identifier> newx </identifier></term><symbol> * </symbol><term><identifier> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol><keyword> Else </keyword><symbol> { </symbol><statements><letStatement><keyword> Let </keyword><identifier> newy </identifier><symbol> = </symbol><expression><term><integerConstant> 0 </integerConstant></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><expression><term><identifier> divLengthx </identifier></term><symbol> * </symbol><term><integerConstant> 25 </integerConstant></term></expression><symbol> ) </symbol></term><symbol> / </symbol><term><identifier> divLengthy </identifier></term></expression><symbol> ; </symbol></letStatement><letStatement><keyword> Let </keyword><identifier> newx </identifier><symbol> = </symbol><expression><term><identifier> x </identifier></term><symbol> + </symbol><term><expression><term><identifier> newx </identifier></term><symbol> * </symbol><term><identifier> factor </identifier></term></expression><symbol> ) </symbol></term></expression><symbol> ; </symbol></letStatement></statements><symbol> } </symbol></statements><symbol> } </symbol></statements><symbol> } </symbol><doStatement><keyword> Do </keyword><identifier> setDestination </identifier><symbol> ( </symbol><expressionList><expression><term><identifier> newx </identifier></term></expression><symbol> , </symbol><expression><term><identifier> newy </identifier></term></expression></expressionList><symbol> ) </symbol><symbol> ; </symbol></doStatement><returnStatement><keyword> Return </keyword><symbol> ; </symbol></returnStatement></statements><symbol> } </symbol></subroutineBody></subroutineDec><symbol> } </symbol></class>